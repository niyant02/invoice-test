### This file was generated by Nexus Schema
### Do not make changes to this file directly


type ClientAddress {
  city: String!
  country: String!
  id: Int!
  invoice(after: InvoiceWhereUniqueInput, before: InvoiceWhereUniqueInput, first: Int, last: Int): [Invoice!]!
  postCode: String!
  street: String!
}

input ClientAddressCreateNestedOneWithoutInvoiceInput {
  connect: ClientAddressWhereUniqueInput
  connectOrCreate: ClientAddressCreateOrConnectWithoutInvoiceInput
  create: ClientAddressCreateWithoutInvoiceInput
}

input ClientAddressCreateOrConnectWithoutInvoiceInput {
  create: ClientAddressCreateWithoutInvoiceInput!
  where: ClientAddressWhereUniqueInput!
}

input ClientAddressCreateWithoutInvoiceInput {
  city: String!
  country: String!
  postCode: String!
  street: String!
}

input ClientAddressOrderByInput {
  city: SortOrder
  country: SortOrder
  id: SortOrder
  postCode: SortOrder
  street: SortOrder
}

input ClientAddressUpdateOneWithoutInvoiceInput {
  connect: ClientAddressWhereUniqueInput
  connectOrCreate: ClientAddressCreateOrConnectWithoutInvoiceInput
  create: ClientAddressCreateWithoutInvoiceInput
  delete: Boolean
  disconnect: Boolean
  update: ClientAddressUpdateWithoutInvoiceInput
  upsert: ClientAddressUpsertWithoutInvoiceInput
}

input ClientAddressUpdateWithoutInvoiceInput {
  city: StringFieldUpdateOperationsInput
  country: StringFieldUpdateOperationsInput
  postCode: StringFieldUpdateOperationsInput
  street: StringFieldUpdateOperationsInput
}

input ClientAddressUpsertWithoutInvoiceInput {
  create: ClientAddressCreateWithoutInvoiceInput!
  update: ClientAddressUpdateWithoutInvoiceInput!
}

input ClientAddressWhereInput {
  AND: [ClientAddressWhereInput!]
  NOT: [ClientAddressWhereInput!]
  OR: [ClientAddressWhereInput!]
  city: StringFilter
  country: StringFilter
  id: IntFilter
  invoice: InvoiceListRelationFilter
  postCode: StringFilter
  street: StringFilter
}

input ClientAddressWhereUniqueInput {
  id: Int
}

"""
A date string, such as 2007-12-03, compliant with the `full-date` format outlined in section 5.6 of the RFC 3339 profile of the ISO 8601 standard for representation of dates and times using the Gregorian calendar.
"""
scalar Date

"""
A date-time string at UTC, such as 2007-12-03T10:15:30Z, compliant with the `date-time` format outlined in section 5.6 of the RFC 3339 profile of the ISO 8601 standard for representation of dates and times using the Gregorian calendar.
"""
scalar DateTime

input DateTimeFieldUpdateOperationsInput {
  set: DateTime
}

input DateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeFilter
  notIn: [DateTime!]
}

input DateTimeNullableFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeNullableFilter
  notIn: [DateTime!]
}

scalar Decimal

input DecimalFieldUpdateOperationsInput {
  decrement: Decimal
  divide: Decimal
  increment: Decimal
  multiply: Decimal
  set: Decimal
}

input DecimalFilter {
  equals: Decimal
  gt: Decimal
  gte: Decimal
  in: [Decimal!]
  lt: Decimal
  lte: Decimal
  not: NestedDecimalFilter
  notIn: [Decimal!]
}

input IntFieldUpdateOperationsInput {
  decrement: Int
  divide: Int
  increment: Int
  multiply: Int
  set: Int
}

input IntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int!]
}

input IntNullableFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntNullableFilter
  notIn: [Int!]
}

type Invoice {
  clientAddress: ClientAddress
  clientAddressId: Int
  clientEmail: String!
  clientName: String!
  createdAt: DateTime
  description: String
  id: String!
  invoiceItems(after: InvoiceItemsWhereUniqueInput, before: InvoiceItemsWhereUniqueInput, first: Int, last: Int): [InvoiceItems!]!
  paymentDue: DateTime
  paymentTerms: Int
  senderAddress: SenderAddress
  senderAddressId: Int
  status: String!
  total: Decimal!
  updatedAt: DateTime
}

input InvoiceCreateInput {
  clientAddress: ClientAddressCreateNestedOneWithoutInvoiceInput
  clientEmail: String!
  clientName: String!
  createdAt: DateTime
  description: String
  id: String!
  invoiceItems: InvoiceItemsCreateNestedManyWithoutInvoiceInput
  paymentDue: DateTime
  paymentTerms: Int
  senderAddress: SenderAddressCreateNestedOneWithoutInvoiceInput
  status: String!
  total: Decimal!
  updatedAt: DateTime
}

type InvoiceItems {
  id: Int!
  invoice: Invoice!
  invoiceId: String!
  name: String!
  price: Decimal!
  quantity: Int!
  total: Decimal!
}

input InvoiceItemsCreateManyInvoiceInput {
  id: Int
  name: String!
  price: Decimal!
  quantity: Int!
  total: Decimal!
}

input InvoiceItemsCreateManyInvoiceInputEnvelope {
  data: [InvoiceItemsCreateManyInvoiceInput!]
  skipDuplicates: Boolean
}

input InvoiceItemsCreateNestedManyWithoutInvoiceInput {
  connect: [InvoiceItemsWhereUniqueInput!]
  connectOrCreate: [InvoiceItemsCreateOrConnectWithoutInvoiceInput!]
  create: [InvoiceItemsCreateWithoutInvoiceInput!]
  createMany: InvoiceItemsCreateManyInvoiceInputEnvelope
}

input InvoiceItemsCreateOrConnectWithoutInvoiceInput {
  create: InvoiceItemsCreateWithoutInvoiceInput!
  where: InvoiceItemsWhereUniqueInput!
}

input InvoiceItemsCreateWithoutInvoiceInput {
  name: String!
  price: Decimal!
  quantity: Int!
  total: Decimal!
}

input InvoiceItemsListRelationFilter {
  every: InvoiceItemsWhereInput
  none: InvoiceItemsWhereInput
  some: InvoiceItemsWhereInput
}

input InvoiceItemsScalarWhereInput {
  AND: [InvoiceItemsScalarWhereInput!]
  NOT: [InvoiceItemsScalarWhereInput!]
  OR: [InvoiceItemsScalarWhereInput!]
  id: IntFilter
  invoiceId: StringFilter
  name: StringFilter
  price: DecimalFilter
  quantity: IntFilter
  total: DecimalFilter
}

input InvoiceItemsUpdateManyMutationInput {
  name: StringFieldUpdateOperationsInput
  price: DecimalFieldUpdateOperationsInput
  quantity: IntFieldUpdateOperationsInput
  total: DecimalFieldUpdateOperationsInput
}

input InvoiceItemsUpdateManyWithWhereWithoutInvoiceInput {
  data: InvoiceItemsUpdateManyMutationInput!
  where: InvoiceItemsScalarWhereInput!
}

input InvoiceItemsUpdateManyWithoutInvoiceInput {
  connect: [InvoiceItemsWhereUniqueInput!]
  connectOrCreate: [InvoiceItemsCreateOrConnectWithoutInvoiceInput!]
  create: [InvoiceItemsCreateWithoutInvoiceInput!]
  createMany: InvoiceItemsCreateManyInvoiceInputEnvelope
  delete: [InvoiceItemsWhereUniqueInput!]
  deleteMany: [InvoiceItemsScalarWhereInput!]
  disconnect: [InvoiceItemsWhereUniqueInput!]
  set: [InvoiceItemsWhereUniqueInput!]
  update: [InvoiceItemsUpdateWithWhereUniqueWithoutInvoiceInput!]
  updateMany: [InvoiceItemsUpdateManyWithWhereWithoutInvoiceInput!]
  upsert: [InvoiceItemsUpsertWithWhereUniqueWithoutInvoiceInput!]
}

input InvoiceItemsUpdateWithWhereUniqueWithoutInvoiceInput {
  data: InvoiceItemsUpdateWithoutInvoiceInput!
  where: InvoiceItemsWhereUniqueInput!
}

input InvoiceItemsUpdateWithoutInvoiceInput {
  name: StringFieldUpdateOperationsInput
  price: DecimalFieldUpdateOperationsInput
  quantity: IntFieldUpdateOperationsInput
  total: DecimalFieldUpdateOperationsInput
}

input InvoiceItemsUpsertWithWhereUniqueWithoutInvoiceInput {
  create: InvoiceItemsCreateWithoutInvoiceInput!
  update: InvoiceItemsUpdateWithoutInvoiceInput!
  where: InvoiceItemsWhereUniqueInput!
}

input InvoiceItemsWhereInput {
  AND: [InvoiceItemsWhereInput!]
  NOT: [InvoiceItemsWhereInput!]
  OR: [InvoiceItemsWhereInput!]
  id: IntFilter
  invoice: InvoiceWhereInput
  invoiceId: StringFilter
  name: StringFilter
  price: DecimalFilter
  quantity: IntFilter
  total: DecimalFilter
}

input InvoiceItemsWhereUniqueInput {
  id: Int
}

input InvoiceListRelationFilter {
  every: InvoiceWhereInput
  none: InvoiceWhereInput
  some: InvoiceWhereInput
}

input InvoiceOrderByInput {
  clientAddress: ClientAddressOrderByInput
  clientAddressId: SortOrder
  clientEmail: SortOrder
  clientName: SortOrder
  createdAt: SortOrder
  description: SortOrder
  id: SortOrder
  paymentDue: SortOrder
  paymentTerms: SortOrder
  senderAddress: SenderAddressOrderByInput
  senderAddressId: SortOrder
  status: SortOrder
  total: SortOrder
  updatedAt: SortOrder
}

input InvoiceUpdateInput {
  clientAddress: ClientAddressUpdateOneWithoutInvoiceInput
  clientEmail: StringFieldUpdateOperationsInput
  clientName: StringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  description: NullableStringFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  invoiceItems: InvoiceItemsUpdateManyWithoutInvoiceInput
  paymentDue: NullableDateTimeFieldUpdateOperationsInput
  paymentTerms: NullableIntFieldUpdateOperationsInput
  senderAddress: SenderAddressUpdateOneWithoutInvoiceInput
  status: StringFieldUpdateOperationsInput
  total: DecimalFieldUpdateOperationsInput
  updatedAt: NullableDateTimeFieldUpdateOperationsInput
}

input InvoiceWhereInput {
  AND: [InvoiceWhereInput!]
  NOT: [InvoiceWhereInput!]
  OR: [InvoiceWhereInput!]
  clientAddress: ClientAddressWhereInput
  clientAddressId: IntNullableFilter
  clientEmail: StringFilter
  clientName: StringFilter
  createdAt: DateTimeFilter
  description: StringNullableFilter
  id: StringFilter
  invoiceItems: InvoiceItemsListRelationFilter
  paymentDue: DateTimeNullableFilter
  paymentTerms: IntNullableFilter
  senderAddress: SenderAddressWhereInput
  senderAddressId: IntNullableFilter
  status: StringFilter
  total: DecimalFilter
  updatedAt: DateTimeNullableFilter
}

input InvoiceWhereUniqueInput {
  id: String
}

"""
The `JSONObject` scalar type represents JSON objects as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
"""
scalar JSONObject @specifiedBy(url: "http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf")

type Mutation {
  createOneInvoice(data: InvoiceCreateInput!): Invoice!
  deleteOneInvoice(where: InvoiceWhereUniqueInput!): Invoice
  updateOneInvoice(data: InvoiceUpdateInput!, where: InvoiceWhereUniqueInput!): Invoice
}

input NestedDateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeFilter
  notIn: [DateTime!]
}

input NestedDateTimeNullableFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeNullableFilter
  notIn: [DateTime!]
}

input NestedDecimalFilter {
  equals: Decimal
  gt: Decimal
  gte: Decimal
  in: [Decimal!]
  lt: Decimal
  lte: Decimal
  not: NestedDecimalFilter
  notIn: [Decimal!]
}

input NestedIntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int!]
}

input NestedIntNullableFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntNullableFilter
  notIn: [Int!]
}

input NestedStringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

input NestedStringNullableFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringNullableFilter
  notIn: [String!]
  startsWith: String
}

input NullableDateTimeFieldUpdateOperationsInput {
  set: DateTime
}

input NullableIntFieldUpdateOperationsInput {
  decrement: Int
  divide: Int
  increment: Int
  multiply: Int
  set: Int
}

input NullableStringFieldUpdateOperationsInput {
  set: String
}

input NullableUploadFieldUpdateOperationsInput {
  set: Upload
}

type Query {
  invoice(where: InvoiceWhereUniqueInput!): Invoice
  invoices(after: InvoiceWhereUniqueInput, before: InvoiceWhereUniqueInput, first: Int, last: Int, orderBy: [InvoiceOrderByInput!], where: InvoiceWhereInput): [Invoice!]!
}

type Response {
  code: Int
  message: String!
}

type SenderAddress {
  city: String!
  country: String!
  id: Int!
  invoice(after: InvoiceWhereUniqueInput, before: InvoiceWhereUniqueInput, first: Int, last: Int): [Invoice!]!
  postCode: String!
  street: String!
}

input SenderAddressCreateNestedOneWithoutInvoiceInput {
  connect: SenderAddressWhereUniqueInput
  connectOrCreate: SenderAddressCreateOrConnectWithoutInvoiceInput
  create: SenderAddressCreateWithoutInvoiceInput
}

input SenderAddressCreateOrConnectWithoutInvoiceInput {
  create: SenderAddressCreateWithoutInvoiceInput!
  where: SenderAddressWhereUniqueInput!
}

input SenderAddressCreateWithoutInvoiceInput {
  city: String!
  country: String!
  postCode: String!
  street: String!
}

input SenderAddressOrderByInput {
  city: SortOrder
  country: SortOrder
  id: SortOrder
  postCode: SortOrder
  street: SortOrder
}

input SenderAddressUpdateOneWithoutInvoiceInput {
  connect: SenderAddressWhereUniqueInput
  connectOrCreate: SenderAddressCreateOrConnectWithoutInvoiceInput
  create: SenderAddressCreateWithoutInvoiceInput
  delete: Boolean
  disconnect: Boolean
  update: SenderAddressUpdateWithoutInvoiceInput
  upsert: SenderAddressUpsertWithoutInvoiceInput
}

input SenderAddressUpdateWithoutInvoiceInput {
  city: StringFieldUpdateOperationsInput
  country: StringFieldUpdateOperationsInput
  postCode: StringFieldUpdateOperationsInput
  street: StringFieldUpdateOperationsInput
}

input SenderAddressUpsertWithoutInvoiceInput {
  create: SenderAddressCreateWithoutInvoiceInput!
  update: SenderAddressUpdateWithoutInvoiceInput!
}

input SenderAddressWhereInput {
  AND: [SenderAddressWhereInput!]
  NOT: [SenderAddressWhereInput!]
  OR: [SenderAddressWhereInput!]
  city: StringFilter
  country: StringFilter
  id: IntFilter
  invoice: InvoiceListRelationFilter
  postCode: StringFilter
  street: StringFilter
}

input SenderAddressWhereUniqueInput {
  id: Int
}

enum SortOrder {
  asc
  desc
}

input StringFieldUpdateOperationsInput {
  set: String
}

input StringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

input StringNullableFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringNullableFilter
  notIn: [String!]
  startsWith: String
}

type Subscription {
  userSignedIn(id: String!): Invoice
}

"""The `Upload` scalar type represents a file upload."""
scalar Upload
